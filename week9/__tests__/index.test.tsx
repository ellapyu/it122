import React from 'react';
import '@testing-library/jest-dom';
import userEvent from '@testing-library/user-event';
import { render, screen, fireEvent, act, waitFor } from '@testing-library/react';
import {
    RecipeApp,
    RecipeList,
    RecipeRow,
    SingleRecipeEntry,
    EditRecipeEntry,
    RecipeFigure,
    RecipeImgCredit
 } from '../public/js/index';
 beforeEach(() => {
    // Mock the DOM to provide a root div for ReactDOM.createRoot
    const div = document.createElement('div');
    div.setAttribute('id', 'root');
    document.body.appendChild(div);
});

beforeAll(() => {
    global.fetch = jest.fn(() =>
        Promise.resolve({
            json: () => Promise.resolve([]),
            status: 200,
            ok: true,
            redirected: false,
            headers: new Headers(),
        }) as any
    );
});

// Wrap async updates with act() in your test
test('renders RecipeApp and RecipeList inside root div', async () => {
    await act(async () => {
        render(<RecipeApp />);
    });

    // Ensure RecipeList is rendered
    const recipeList = screen.getByTestId('recipe-list');
    expect(recipeList).toBeInTheDocument();
});

// Confirm that clicking on a RecipeRow toggles its isActive state and displays the SingleRecipeEntry component with the recipe details.

// fix the sampleRecipe generated by ChatGPT to reflect interface requirements
const sampleRecipe = { 
    _id: '1',
    name: 'Sample Recipe',
    cuisine: 'My Favorite Cuisine',
    difficulty: 'Easy',
    cook_mins: '30',
    clean_mins: '10',
    ingredients: [],
    recipeImage: '',
    imgCredit: '',
    imgCreditUrl: ''
  };

  const mockUpdateRecipe = jest.fn();
  const mockDeleteRecipe = jest.fn();
  
  test('toggles isActive state and displays SingleRecipeEntry on click', () => {
    render(
      <RecipeRow 
        recipe={sampleRecipe} 
        onUpdateRecipe={mockUpdateRecipe} 
        onDeleteRecipe={mockDeleteRecipe} 
      />
    );
    const recipeRowElement = screen.getByRole('button', { name: /Sample Recipe/i});
    fireEvent.click(recipeRowElement);
  
    // Example element you expect to appear
    expect(screen.getByText(/30 minutes/i)).toBeInTheDocument();
    const cuisineElements = screen.getAllByText(/My Favorite Cuisine/i);
    expect(cuisineElements[0]).toBeInTheDocument();
    expect(cuisineElements[1]).toBeInTheDocument();
  });

  // Edit state toggles as expected and displays editrecipeentry
  
test('toggles isEditing and displays EditRecipeEntry on click', async () => {
    render(
      <SingleRecipeEntry
        selectedRecipe={sampleRecipe}
        onUpdateRecipe={mockUpdateRecipe}
        onDeleteRecipe={mockDeleteRecipe}
      />
    );
  

  // Initially, ensure the form labels for edit mode are not visible
  expect(screen.queryByText(/Recipe name:/)).toBeNull();
  expect(screen.queryByText(/Link to source page:/)).toBeNull();

  // Get the "Edit Recipe" button that toggles the isEditing state
  const editButton = screen.getByRole('button', { name: /Edit Recipe/i });
  fireEvent.click(editButton);

  // Wait for EditRecipeEntry to appear after state change
  await waitFor(() => screen.getByText(/Recipe name:/));
});

test('edits and submits updated recipe data in EditRecipeEntry ', async () => {
  // Mock function for updating the recipe
  const mockUpdateRecipe = jest.fn();
  const mockOnClose = jest.fn();

  render(
    <EditRecipeEntry
      selectedRecipe={sampleRecipe}
      onSave={mockUpdateRecipe}
      onClose={mockOnClose}
      isPOST={false}
    />
  );

  // Check if initial values are in the input fields
  const nameInput = screen.getByLabelText(/Recipe name:/);
  const cuisineInput = screen.getByLabelText(/Cuisine:/);

  // Ensure the edit form labels are now visible
  expect(nameInput).toBeInTheDocument();
  expect(cuisineInput).toBeInTheDocument();
  expect(screen.getByLabelText(/Link to source page:/)).toBeInTheDocument();

  // Ensure initial value matches the sample recipe
  expect(nameInput).toHaveValue('Sample Recipe');
  expect(cuisineInput).toHaveValue('My Favorite Cuisine');

  // Clear and type new values into the fields
  await userEvent.clear(nameInput);
  await userEvent.type(nameInput, 'Updated Recipe Name');
  await userEvent.clear(cuisineInput);
  await userEvent.type(cuisineInput, 'New Cuisine');

  
  // Ensure the values are updated in the inputs
  expect(nameInput).toHaveValue('Updated Recipe Name');
  expect(cuisineInput).toHaveValue('New Cuisine');

  // Submit the form (this may be a button or a form submit)
  const submitButton = screen.getByDisplayValue(/Save/i);
  await userEvent.click(submitButton);
});

test('verifies updated recipe values in RecipeRow inside RecipeList after EditRecipeEntry submit', async () => {
  // Step 1: Mock the update function and the initial recipe
  const mockUpdateRecipe = jest.fn();
  const mockDeleteRecipe = jest.fn();
  
  const updatedRecipe = {
      ...sampleRecipe,
      name: 'Updated Recipe Name',
      cuisine: 'New Cuisine',
  };

  // Step 2: Render RecipeList with the updated recipe
  render(
    <RecipeList recipes={[updatedRecipe]} onUpdateRecipe={mockUpdateRecipe} onDeleteRecipe={mockDeleteRecipe} />
  );

  // Step 3: Assert that the updated recipe name and cuisine are correctly displayed in RecipeRow
  expect(screen.getByText('Updated Recipe Name - New Cuisine')).toBeInTheDocument();
});
